from __future__ import annotations
import re
from collections import Counter
from typing import List, Tuple

PAGE_RX = re.compile(r"\bpage\s*\d+\s*(of\s*\d+)?\b", re.I)
DOCCTL_RX = re.compile(r"\b(document control|version|generated by|template)\b", re.I)

AR_PAGE_RX = re.compile(r"(صفحة\s*\d+)", re.I)

def normalize_line(line: str) -> str:
    s = line.strip()
    s = re.sub(r"\s+", " ", s)
    s = PAGE_RX.sub("page", s)
    s = AR_PAGE_RX.sub("صفحة", s)
    s = re.sub(r"\b\d{2,}\b", "0", s)  # normalize numbers
    return s.lower()

def detect_boilerplate_lines(text: str, *, min_len: int = 8, min_repeat_ratio: float = 0.35) -> Tuple[List[str], str]:
    """
    Finds repeated lines (headers/footers/templates).
    Returns: (boilerplate_lines, cleaned_text)
    """
    lines = [ln.strip() for ln in text.splitlines()]
    lines = [ln for ln in lines if len(ln.strip()) >= min_len]

    norm = [normalize_line(ln) for ln in lines]
    counts = Counter(norm)

    # Anything repeating often is likely boilerplate
    # In long PDFs, headers repeat on many pages -> high count.
    threshold = max(3, int(len(lines) * min_repeat_ratio * 0.05))  # adaptive, conservative
    boiler_norm = {k for k, v in counts.items() if v >= threshold}

    boiler = []
    kept = []
    for raw, n in zip(lines, norm):
        if n in boiler_norm or DOCCTL_RX.search(raw):
            boiler.append(raw)
        else:
            kept.append(raw)

    cleaned = "\n".join(kept)
    return boiler[:200], cleaned
